// GMenuPlugin
// Initial code generated by XSI SDK Wizard
// Executed Sun Feb 7 17:30:50 UTC+0900 2010 by yama
// 
// Tip: You need to compile the generated code before you can load the plug-in.
// After you compile the plug-in, you can load it by clicking Update All in the Plugin Manager.
#include <tchar.h>
#include <windows.h>

#include <xsi_application.h>
#include <xsi_context.h>
#include <xsi_pluginregistrar.h>
#include <xsi_status.h>
#include <xsi_argument.h>
#include <xsi_command.h>
#include <xsi_desktop.h>
using namespace XSI;

#define GLOBAL_VALUE_DEFINE
#include "GMenuSub.h"

/* メニューウィンドウメッセージ処理 */
LRESULT CALLBACK WndProc(HWND hwnd , UINT msg , WPARAM wp , LPARAM lp) {
	HDC hdc;
	PAINTSTRUCT ps;
	CREATESTRUCT *cs;
	static struct GDATA *data;
	static int gMenuSplits;
	static TCHAR **gMenuText;
	static HRGN *hRgnMenu;
	static HRGN *hRgnAMenu;
	static POINT pt;
	static BOOL bIn;
	static int cRgn;
	static HRGN hWindow;
	int x,y;
	int num;

	switch (msg) {
	case WM_CREATE: // Windowが最初に作られたとき（一度だけ実行されるので、各種初期化処理）
		cs = (CREATESTRUCT *)lp;
		data = (GDATA *)cs->lpCreateParams;
		gMenuSplits = data->gMenuSplits;
		gMenuText = (TCHAR **)&(data->gMenuText[0][0]);
		hRgnMenu = data->hRgnMenu;
		hRgnAMenu = data->hRgnAMenu;
		cRgn = -1;
		cmdNum = -1;
		hWindow = CreateEllipticRgn( 1,1, data->gWinSize.right-data->gWinSize.left, data->gWinSize.bottom-data->gWinSize.top );
		SetWindowRgn(hwnd, hWindow, TRUE);
		SetLayeredWindowAttributes(hwnd, RGB(255,0,0), 0, LWA_COLORKEY);
		return 0;

	case WM_KEYDOWN: // キー入力処理
		if (( wp == gKeymap.Forward ) && ( cRgn == -1 )){ // ページング
			if ( GetKeyState( gKeymap.Back ) & 0x80 ) { // 戻る
				if ( data->gMenuPage > 0 )
					data->gMenuPage--;
			} else {									// 進む
				if ( data->gMenuPage < (data->gMenuItemCount/(data->gMenuSplits*1.0))-1 )
					data->gMenuPage++;
			}
			mySetWinSize( data, data->gMenuPage );
			mySetMenuRgn( data, data->gMenuPage );

			MoveWindow( hwnd, data->gWinSize.left, data->gWinSize.top, data->gWinSize.right - data->gWinSize.left, data->gWinSize.bottom - data->gWinSize.top, FALSE );
			DeleteObject( hWindow );
			hWindow = CreateEllipticRgn( 1,1, data->gWinSize.right-data->gWinSize.left, data->gWinSize.bottom-data->gWinSize.top );
			SetWindowRgn(hwnd, hWindow, FALSE);
			InvalidateRect( hwnd, NULL, TRUE );
			gMenuText = (TCHAR **)&(data->gMenuText[data->gMenuPage*data->gMenuSplits][0]);
			cRgn = -1;
		} else if ( wp == gKeymap.Cancel ) { // Cancel
			SendMessage(hwnd, WM_CLOSE, 0, 0); // Window閉じる
		} else if ( wp == gKeymap.Select ) { // Select
			if ( cRgn != -1 ) {
				cmdNum = cRgn;
			}
			SendMessage(hwnd, WM_CLOSE, 0, 0); // Window閉じる
		}
		return 0;

	case WM_LBUTTONDOWN:    // マウス左クリック
		if ( cRgn != -1 ) { // アクティブなメニューがあれば、メニューIndexをセット
			cmdNum = cRgn;
		}
		SendMessage(hwnd, WM_CLOSE, 0, 0); // Window閉じる
		return 0;

	case WM_RBUTTONDOWN: // マウス右クリック
		if ( cRgn == -1 ) {
			//
		} else {
			//
		}
		SendMessage(hwnd, WM_CLOSE, 0, 0); // Window閉じる
		return 0;

	case WM_KILLFOCUS:   // メニューWindow以外にフォーカスが移った時
		SendMessage(hwnd, WM_CLOSE, 0, 0); // Window閉じる
		return 0;

	case WM_DESTROY: // 終了メッセージ
		PostQuitMessage(0);
		return 0;

	case WM_PAINT: // 描画処理
		hdc = BeginPaint(hwnd , &ps);
		SelectObject( hdc, CreateSolidBrush(RGB(255, 0, 0)) );
		ExtFloodFill( hdc, (data->gWinSize.right-data->gWinSize.left)/2, (data->gWinSize.bottom-data->gWinSize.top)/2,  RGB(255,255,255), FLOODFILLSURFACE );
		SelectObject( hdc, CreateSolidBrush(RGB(200, 200, 200)) );
		for (int i=0; i<gMenuSplits; i++ ) { // メニュー用のリージョン描画
			PaintRgn(hdc , hRgnMenu[i]);
		}
		SelectObject( hdc, GetStockObject( DEFAULT_GUI_FONT ) ); // メニューフォント設定
		SelectObject( hdc, CreateSolidBrush(RGB(0,0,0)) ); // フォントの色設定
		SetBkMode( hdc, TRANSPARENT ); // フォント描画モード設定
		num = data->gMenuPage * data->gMenuSplits;
		for ( int i=0; i<data->gMenuSplits; i++ ) { // メニューフォント描画
			TextOut( hdc, data->gMenuTextPos[i].x, data->gMenuTextPos[i].y, data->gMenuText[i+num], lstrlen( data->gMenuText[i+num] ) );
		}
		EndPaint(hwnd , &ps);

		return 0;

	case WM_MOUSEMOVE: // マウス移動
		pt.x = LOWORD(lp);
		pt.y = HIWORD(lp);
		hdc = GetDC( hwnd );
		for (int i=0; i<gMenuSplits; i++ ) { // メニュー選択検知
			bIn = PtInRegion( hRgnAMenu[i], pt.x, pt.y ); // 検知用リージョン内かチェック
			if ( bIn ) {
				if ( cRgn != i ) { // 前のリージョン番号と違うなら（反転表示処理）
					if ( cRgn == -1 ) { // 初メニューリージョンアクティブ時（反転表示処理）
						InvertRgn( hdc, hRgnMenu[i] );
					} else { // リージョンからリージョンへ移動時（反転表示処理）
						InvertRgn( hdc, hRgnMenu[cRgn] );
						InvertRgn( hdc, hRgnMenu[i] );
					}
					cRgn = i; // 選択されたリージョン番号をセット
				}
//				DebugLog(L"IN REGION" + CString(cRgn));
			} else {
			}
		}
		if (( cRgn != -1 ) && myInC0( data, pt )) {
			InvertRgn( hdc, hRgnMenu[cRgn] );
			cRgn = -1;
		}
		ReleaseDC(hwnd, hdc);
		return 0;
	}

	return DefWindowProc(hwnd , msg , wp , lp); // 定義してないメッセージ処理をお願い
}

/* メニュー用ウィンドウクラス登録 */
static ATOM myWindowClassReg( HINSTANCE hInst )
{
    WNDCLASS        wc;

    wc.style        =CS_HREDRAW|CS_VREDRAW; 
    wc.lpfnWndProc  =WndProc;
    wc.cbClsExtra   =0;
    wc.cbWndExtra   =0;
    wc.hInstance    =hInst;
    wc.hIcon        =NULL;
    wc.hCursor      =LoadCursor(0,MAKEINTRESOURCE(IDC_ARROW));
    wc.hbrBackground=(HBRUSH)GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =NULL;
    wc.lpszClassName=szClassName;


    return (RegisterClass(&wc));
}

/* Plugin ロードエントリ */
XSIPLUGINCALLBACK CStatus XSILoadPlugin( PluginRegistrar& in_reg )
{
	in_reg.PutAuthor(L"oyaG");
	in_reg.PutName(L"GMenuPlugin");
	in_reg.PutEmail(L"");
	in_reg.PutURL(L"");
	in_reg.PutVersion(1,0);
	in_reg.RegisterCommand(L"GMenu",L"GMenu");
	//RegistrationInsertionPoint - do not remove this line

	Application().LogMessage(in_reg.GetName() + L" is loading.",siVerboseMsg);
	return CStatus::OK;
}

/* Plugin アンロードエントリ */
XSIPLUGINCALLBACK CStatus XSIUnloadPlugin( const PluginRegistrar& in_reg )
{
	CString strPluginName;
	strPluginName = in_reg.GetName();
	UnregisterClass( szClassName, gInstance );
	Application().LogMessage(strPluginName + L" has been unloaded.",siVerboseMsg);
	return CStatus::OK;
}

/* メニューコマンドパラメータ定義 */
/* GMenu メニューセット名		  */
/* で呼び出される				  */
/* ウィンドウクラス登録実行、XSIのウィンドウハンドル取得はここで */
XSIPLUGINCALLBACK CStatus GMenu_Init( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );
	Command oCmd(ctxt.GetSource());
	oCmd.PutDescription(L"");
	oCmd.SetFlag(siCannotBeUsedInBatch,true);
	oCmd.SetFlag(siNoLogging,true);
	oCmd.EnableReturnValue(true);

	ArgumentArray oArgs = oCmd.GetArguments();
	oArgs.Add(L"MenuSetName");

	gWnd = (HWND)Application().GetDesktop().GetApplicationWindowHandle();	//XSI のウィンドウハンドル
	gInstance = GetModuleHandle(NULL);										//自分のインスタンス


	if ( myWindowClassReg( gInstance ) == 0 ) {	//ウィンドウクラス登録
		Application().LogMessage(L" cannnot regiser window class.",siVerboseMsg);
		return CStatus::False;
	}
	DebugLog(L" registered windows class.");
	return CStatus::OK;
}

/* メニュー処理を実エントリ。　メッセージループへ突入 */
XSIPLUGINCALLBACK CStatus GMenu_Execute( CRef& in_ctxt )
{
	Context ctxt( in_ctxt );

	Command oCmd(ctxt.GetSource());

	lstrcpy( gFilePath ,oCmd.GetFileName().GetWideString() ); //自分のファイルパス
//	cmdBuf = (TCHAR *)calloc( BUF_SIZE, sizeof(TCHAR) ); //実行用バッファ確保

	DebugLog(L"GMenu_Execute called:");
/////////////////////////////////////////////////////////////////////////
	int mode = myGetToolBarMode( gWnd );
	DebugLog( L"Mode:" + CString(mode) );
/////////////////////////////////////////////////////////////////////////
	// 
	// TODO: Put your command implementation here.
	if ( ! myInitData( in_ctxt, mode )) //メニュー用データロード＆初期化
		return CStatus::False;
//return CStatus::OK;
////////////////////////////////////////////////////////////////////////
//	struct GDATA *data = (struct GDATA *)( (CValue::siPtrType)ctxt.GetUserData() );
	struct GDATA *data = &gMenu; //メニュー表示用データ

	HWND hWnd = CreateWindowEx(WS_EX_LAYERED,
            szClassName, L"GMenu",
			/*WS_OVERLAPPEDWINDOW|*/ WS_POPUP,
			data->gWinSize.left , data->gWinSize.top ,
			data->gWinSize.right - data->gWinSize.left, data->gWinSize.bottom - data->gWinSize.top,
            gWnd, //親ウィンドウのハンドル、親を作るときはNULL
            NULL, //メニューハンドル、クラスメニューを使うときはNULL
            gInstance, //インスタンスハンドル
            data); // カスタムデータ

	if (!hWnd) { // Windowハンドルチェック
		Application().LogMessage(L"Cannot create menu window");
		return CStatus::False;
	} else {
		data->hWnd = hWnd;
	}

    ShowWindow(hWnd, SW_SHOWNORMAL);
    UpdateWindow(hWnd);

	DebugLog(L"While start");
	MSG msg;

	while(GetMessage(&msg , NULL , 0 , 0)) DispatchMessage(&msg); //メッセージループ

	DebugLog(L"While End");
	// 
	// Return a value by setting this attribute:
	ctxt.PutAttribute( L"ReturnValue", true );

	if ( cmdNum != -1 ) // メニュー実行
		myExec( data, cmdNum );

	// Return CStatus::Fail if you want to raise a script error
	return CStatus::OK;
}
